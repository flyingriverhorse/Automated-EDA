/**
 * Export Manager - Notebook Generation, Multi-format Export, and History Tracking
 * Handles exporting analysis results, generating Jupyter notebooks, and managing export history
 */

class ExportManager {
    constructor() {
        this.exportHistory = [];
        this.activeExports = new Map();
        this.supportedFormats = {
            notebook: {
                extension: '.ipynb',
                mimeType: 'application/json',
                description: 'Jupyter Notebook'
            },
            html: {
                extension: '.html',
                mimeType: 'text/html',
                description: 'HTML Report'
            },
            pdf: {
                extension: '.pdf',
                mimeType: 'application/pdf',
                description: 'PDF Report'
            },
            python: {
                extension: '.py',
                mimeType: 'text/x-python',
                description: 'Python Script'
            },
            csv: {
                extension: '.csv',
                mimeType: 'text/csv',
                description: 'CSV Data'
            }
        };
        this.templates = {};
    }

    /**
     * Initialize the export manager
     */
    initialize() {
        console.log('ExportManager: Initializing...');
        
        // Load export templates
        this.loadExportTemplates();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Load export history from localStorage
        this.loadExportHistory();
        
        console.log('ExportManager: Initialized successfully');
    }

    /**
     * Load export templates
     */
    loadExportTemplates() {
        this.templates = {
            notebook: {
                metadata: {
                    kernelspec: {
                        display_name: "Python 3",
                        language: "python",
                        name: "python3"
                    },
                    language_info: {
                        name: "python",
                        version: "3.8.0"
                    }
                },
                nbformat: 4,
                nbformat_minor: 4
            },
            
            html: {
                template: `
<!DOCTYPE html>
<html>
<head>
    <title>EDA Report - {{dataset_name}}</title>
    <meta charset="utf-8">
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; }
        .header { text-align: center; border-bottom: 2px solid #ddd; padding-bottom: 20px; }
        .section { margin: 30px 0; }
        .chart-container { text-align: center; margin: 20px 0; }
        .code-block { background: #f5f5f5; padding: 15px; border-radius: 5px; font-family: monospace; }
        .insight { background: #e7f3ff; padding: 15px; border-radius: 5px; margin: 10px 0; }
    </style>
</head>
<body>
    {{content}}
</body>
</html>
                `
            },
            
            python: {
                header: `# EDA Analysis Script
# Generated by MLops Platform
# Dataset: {{dataset_name}}
# Generated: {{timestamp}}

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Load the data
# df = pd.read_csv('your_dataset.csv')  # Update with your data path

`
            }
        };
    }

    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Listen for export requests
        document.addEventListener('exportRequested', (event) => {
            this.handleExportRequest(event.detail);
        });
        
        // Listen for analysis completion to auto-save
        document.addEventListener('analysisCompleted', (event) => {
            if (event.detail.autoSave) {
                this.autoSaveAnalysis(event.detail);
            }
        });
    }

    /**
     * Export analysis in specified format
     */
    async exportAnalysis(format, options = {}) {
        try {
            console.log(`ExportManager: Starting export in ${format} format`);
            
            if (!this.supportedFormats[format]) {
                throw new Error(`Unsupported format: ${format}`);
            }
            
            // Generate unique export ID
            const exportId = this.generateExportId();
            
            // Show progress
            this.showExportProgress(exportId, format);
            
            // Collect data from active tabs
            const exportData = await this.collectExportData(options);
            
            // Generate export based on format
            let result;
            switch (format) {
                case 'notebook':
                    result = await this.exportToNotebook(exportData, options);
                    break;
                case 'html':
                    result = await this.exportToHTML(exportData, options);
                    break;
                case 'pdf':
                    result = await this.exportToPDF(exportData, options);
                    break;
                case 'python':
                    result = await this.exportToPython(exportData, options);
                    break;
                case 'csv':
                    result = await this.exportToCSV(exportData, options);
                    break;
                default:
                    throw new Error(`Export format ${format} not implemented`);
            }
            
            // Download the file
            this.downloadFile(result, format);
            
            // Record export in history
            this.recordExport(exportId, format, options, result);
            
            // Hide progress
            this.hideExportProgress(exportId);
            
            console.log(`ExportManager: Export ${exportId} completed successfully`);
            return exportId;
            
        } catch (error) {
            console.error('ExportManager: Export failed:', error);
            this.showExportError(error.message);
            throw error;
        }
    }

    /**
     * Collect data from all tabs for export
     */
    async collectExportData(options) {
        const data = {
            dataset: currentDataset,
            timestamp: new Date().toISOString(),
            domain_analysis: null,
            llm_analysis: null,
            charts: [],
            metadata: {}
        };
        
        // Collect domain analysis data
        if (typeof domainAnalysisState !== 'undefined' && domainAnalysisState.results) {
            data.domain_analysis = {
                template_type: domainAnalysisState.currentTemplate,
                results: domainAnalysisState.results,
                detected_domain: domainAnalysisState.detectedDomain
            };
        }
        
        // Collect LLM analysis data
        if (typeof llmState !== 'undefined' && llmState.sessions[llmState.currentSession]) {
            data.llm_analysis = {
                session_id: llmState.currentSession,
                cells: llmState.sessions[llmState.currentSession].cells,
                chat_history: llmState.chatHistory
            };
        }
        
        // Collect chart data if requested
        if (options.includeVisualizations !== false && typeof EDARenderer !== 'undefined') {
            data.charts = EDARenderer.getAllCharts();
        }
        
        // Add system metadata
        data.metadata = {
            platform: 'MLops Advanced EDA',
            version: '1.0.0',
            export_options: options,
            user_agent: navigator.userAgent,
            screen_resolution: `${screen.width}x${screen.height}`
        };
        
        return data;
    }

    /**
     * Export to Jupyter Notebook format
     */
    async exportToNotebook(data, options) {
        const notebook = {
            ...this.templates.notebook,
            cells: []
        };
        
        // Add title cell
        notebook.cells.push(this.createMarkdownCell(
            `# EDA Analysis Report\n\n**Dataset:** ${data.dataset.name || 'Unknown'}\n\n**Generated:** ${new Date().toLocaleString()}\n\n---`
        ));
        
        // Add dataset info cell
        if (data.dataset) {
            notebook.cells.push(this.createMarkdownCell(`## Dataset Information\n\n- **Rows:** ${data.dataset.info?.rows || 'N/A'}\n- **Columns:** ${data.dataset.info?.columns || 'N/A'}\n- **Size:** ${data.dataset.info?.size || 'N/A'}`));
        }
        
        // Add imports cell
        notebook.cells.push(this.createCodeCell(
            "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Set plotting style\nplt.style.use('default')\nsns.set_palette('husl')\n%matplotlib inline"
        ));
        
        // Add data loading cell
        notebook.cells.push(this.createCodeCell(
            `# Load the dataset\n# Update the path to your actual data file\ndf = pd.read_csv('${data.dataset.name || 'your_data.csv'}')\nprint(f"Dataset shape: {df.shape}")\ndf.head()`
        ));
        
        // Add domain analysis results
        if (data.domain_analysis && options.includeDomainAnalysis !== false) {
            notebook.cells.push(this.createMarkdownCell("## Domain-Specific Analysis"));
            
            if (data.domain_analysis.results.summary) {
                notebook.cells.push(this.createMarkdownCell(
                    `### Executive Summary\n\n${data.domain_analysis.results.summary.overview}`
                ));
            }
            
            // Add analysis sections
            if (data.domain_analysis.results.sections) {
                data.domain_analysis.results.sections.forEach(section => {
                    notebook.cells.push(this.createMarkdownCell(`### ${section.title}`));
                    notebook.cells.push(this.createMarkdownCell(section.content));
                });
            }
        }
        
        // Add LLM analysis results
        if (data.llm_analysis && options.includeLLMAnalysis !== false) {
            notebook.cells.push(this.createMarkdownCell("## AI-Generated Analysis"));
            
            data.llm_analysis.cells.forEach(cell => {
                if (cell.explanation) {
                    notebook.cells.push(this.createMarkdownCell(`### ${cell.explanation}`));
                }
                
                notebook.cells.push(this.createCodeCell(cell.source));
                
                // Add output if available
                if (cell.results && cell.results.output) {
                    notebook.cells.push(this.createCodeCell(
                        `# Output:\n# ${cell.results.output.replace(/\n/g, '\n# ')}`
                    ));
                }
            });
        }
        
        // Add conclusion
        notebook.cells.push(this.createMarkdownCell(
            "## Conclusion\n\nThis analysis was automatically generated by the MLops Advanced EDA Platform. Review and modify the code as needed for your specific use case."
        ));
        
        return {
            content: JSON.stringify(notebook, null, 2),
            filename: `eda_analysis_${data.dataset.name || 'dataset'}_${this.formatTimestamp()}.ipynb`
        };
    }

    /**
     * Export to HTML format
     */
    async exportToHTML(data, options) {
        let content = `
            <div class="header">
                <h1>EDA Analysis Report</h1>
                <h2>${data.dataset.name || 'Dataset'}</h2>
                <p>Generated on ${new Date().toLocaleString()}</p>
            </div>
        `;
        
        // Add dataset information
        if (data.dataset.info) {
            content += `
                <div class="section">
                    <h2>Dataset Information</h2>
                    <ul>
                        <li><strong>Rows:</strong> ${data.dataset.info.rows || 'N/A'}</li>
                        <li><strong>Columns:</strong> ${data.dataset.info.columns || 'N/A'}</li>
                        <li><strong>Size:</strong> ${data.dataset.info.size || 'N/A'}</li>
                        <li><strong>Quality Score:</strong> ${data.dataset.info.quality_score || 'N/A'}%</li>
                    </ul>
                </div>
            `;
        }
        
        // Add domain analysis
        if (data.domain_analysis) {
            content += `
                <div class="section">
                    <h2>Domain-Specific Analysis</h2>
                    <p><strong>Detected Domain:</strong> ${data.domain_analysis.detected_domain?.primary_domain || 'General'}</p>
            `;
            
            if (data.domain_analysis.results.insights) {
                content += '<h3>Key Insights</h3>';
                data.domain_analysis.results.insights.forEach(insight => {
                    content += `
                        <div class="insight">
                            <strong>${insight.title}</strong><br>
                            ${insight.description}
                        </div>
                    `;
                });
            }
            
            content += '</div>';
        }
        
        // Add LLM analysis
        if (data.llm_analysis && data.llm_analysis.cells.length > 0) {
            content += `
                <div class="section">
                    <h2>AI-Generated Analysis</h2>
            `;
            
            data.llm_analysis.cells.forEach((cell, index) => {
                if (cell.explanation) {
                    content += `<h3>Analysis ${index + 1}: ${cell.explanation}</h3>`;
                }
                
                content += `
                    <div class="code-block">
                        <pre>${this.escapeHtml(cell.source)}</pre>
                    </div>
                `;
                
                if (cell.results && cell.results.output) {
                    content += `
                        <div class="section">
                            <h4>Output:</h4>
                            <pre>${this.escapeHtml(cell.results.output)}</pre>
                        </div>
                    `;
                }
            });
            
            content += '</div>';
        }
        
        // Apply template
        const htmlContent = this.templates.html.template
            .replace('{{dataset_name}}', data.dataset.name || 'Dataset')
            .replace('{{content}}', content);
        
        return {
            content: htmlContent,
            filename: `eda_report_${data.dataset.name || 'dataset'}_${this.formatTimestamp()}.html`
        };
    }

    /**
     * Export to Python script
     */
    async exportToPython(data, options) {
        let script = this.templates.python.header
            .replace('{{dataset_name}}', data.dataset.name || 'Unknown')
            .replace('{{timestamp}}', new Date().toLocaleString());
        
        // Add domain analysis code
        if (data.domain_analysis) {
            script += `\n# Domain-Specific Analysis\n`;
            script += `# Detected domain: ${data.domain_analysis.detected_domain?.primary_domain || 'General'}\n\n`;
        }
        
        // Add LLM generated code
        if (data.llm_analysis && data.llm_analysis.cells.length > 0) {
            script += `\n# AI-Generated Analysis Code\n\n`;
            
            data.llm_analysis.cells.forEach((cell, index) => {
                if (cell.explanation) {
                    script += `# ${cell.explanation}\n`;
                }
                script += `${cell.source}\n\n`;
            });
        }
        
        script += `\n# End of generated script\nprint("Analysis completed!")\n`;
        
        return {
            content: script,
            filename: `eda_analysis_${data.dataset.name || 'dataset'}_${this.formatTimestamp()}.py`
        };
    }

    /**
     * Export to CSV (data only)
     */
    async exportToCSV(data, options) {
        // This would typically export the processed data
        // For now, we'll create a summary CSV
        
        const csvContent = [
            'Metric,Value',
            `Dataset Name,${data.dataset.name || 'N/A'}`,
            `Export Date,${new Date().toISOString()}`,
            `Rows,${data.dataset.info?.rows || 'N/A'}`,
            `Columns,${data.dataset.info?.columns || 'N/A'}`,
            `Quality Score,${data.dataset.info?.quality_score || 'N/A'}%`,
            `Domain,${data.domain_analysis?.detected_domain?.primary_domain || 'N/A'}`
        ].join('\n');
        
        return {
            content: csvContent,
            filename: `eda_summary_${data.dataset.name || 'dataset'}_${this.formatTimestamp()}.csv`
        };
    }

    /**
     * Export to PDF (placeholder - would require server-side generation)
     */
    async exportToPDF(data, options) {
        // In a real implementation, this would call a backend service
        // For now, we'll generate HTML and suggest PDF conversion
        
        const htmlResult = await this.exportToHTML(data, options);
        
        return {
            content: htmlResult.content,
            filename: htmlResult.filename.replace('.html', '_for_pdf.html'),
            message: 'HTML file generated for PDF conversion. Use your browser\'s "Print to PDF" function.'
        };
    }

    /**
     * Create markdown cell for notebook
     */
    createMarkdownCell(source) {
        return {
            cell_type: "markdown",
            metadata: {},
            source: source.split('\n')
        };
    }

    /**
     * Create code cell for notebook
     */
    createCodeCell(source) {
        return {
            cell_type: "code",
            execution_count: null,
            metadata: {},
            outputs: [],
            source: source.split('\n')
        };
    }

    /**
     * Download file to user's computer
     */
    downloadFile(result, format) {
        const formatInfo = this.supportedFormats[format];
        const blob = new Blob([result.content], { type: formatInfo.mimeType });
        const url = window.URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = result.filename;
        
        document.body.appendChild(a);
        a.click();
        
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        // Show success message
        if (result.message) {
            this.showExportMessage(result.message, 'info');
        } else {
            this.showExportMessage(`Export completed: ${result.filename}`, 'success');
        }
    }

    /**
     * Show export progress
     */
    showExportProgress(exportId, format) {
        this.activeExports.set(exportId, {
            format: format,
            startTime: Date.now(),
            status: 'processing'
        });
        
        // Show progress notification
        this.showExportMessage(`Preparing ${format.toUpperCase()} export...`, 'info');
    }

    /**
     * Hide export progress
     */
    hideExportProgress(exportId) {
        this.activeExports.delete(exportId);
    }

    /**
     * Show export message
     */
    showExportMessage(message, type = 'info') {
        // Create toast notification
        const toast = document.createElement('div');
        toast.className = `toast align-items-center text-white bg-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'primary'} border-0`;
        toast.style.position = 'fixed';
        toast.style.top = '20px';
        toast.style.right = '20px';
        toast.style.zIndex = '9999';
        
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <i class="bi bi-${type === 'error' ? 'exclamation-triangle' : type === 'success' ? 'check-circle' : 'info-circle'}"></i>
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;
        
        document.body.appendChild(toast);
        
        if (typeof bootstrap !== 'undefined') {
            const bsToast = new bootstrap.Toast(toast, { delay: 5000 });
            bsToast.show();
            
            toast.addEventListener('hidden.bs.toast', () => {
                document.body.removeChild(toast);
            });
        } else {
            // Fallback without Bootstrap
            setTimeout(() => {
                if (document.body.contains(toast)) {
                    document.body.removeChild(toast);
                }
            }, 5000);
        }
    }

    /**
     * Show export error
     */
    showExportError(message) {
        this.showExportMessage(`Export failed: ${message}`, 'error');
    }

    /**
     * Record export in history
     */
    recordExport(exportId, format, options, result) {
        const exportRecord = {
            id: exportId,
            format: format,
            filename: result.filename,
            timestamp: new Date().toISOString(),
            dataset: currentDataset?.name || 'Unknown',
            options: options,
            size: result.content.length
        };
        
        this.exportHistory.unshift(exportRecord);
        
        // Keep only last 50 exports
        if (this.exportHistory.length > 50) {
            this.exportHistory = this.exportHistory.slice(0, 50);
        }
        
        // Save to localStorage
        this.saveExportHistory();
    }

    /**
     * Get export history
     */
    getExportHistory() {
        return this.exportHistory;
    }

    /**
     * Save export history to localStorage
     */
    saveExportHistory() {
        try {
            localStorage.setItem('eda_export_history', JSON.stringify(this.exportHistory));
        } catch (error) {
            console.warn('ExportManager: Could not save export history:', error);
        }
    }

    /**
     * Load export history from localStorage
     */
    loadExportHistory() {
        try {
            const stored = localStorage.getItem('eda_export_history');
            if (stored) {
                this.exportHistory = JSON.parse(stored);
            }
        } catch (error) {
            console.warn('ExportManager: Could not load export history:', error);
            this.exportHistory = [];
        }
    }

    /**
     * Auto-save analysis results
     */
    async autoSaveAnalysis(analysisData) {
        try {
            const exportData = await this.collectExportData({ autoSave: true });
            const result = await this.exportToNotebook(exportData, { autoSave: true });
            
            // Store in browser storage for recovery
            const autoSaveData = {
                timestamp: new Date().toISOString(),
                content: result.content,
                dataset: currentDataset?.name
            };
            
            localStorage.setItem('eda_auto_save', JSON.stringify(autoSaveData));
            
            console.log('ExportManager: Analysis auto-saved');
        } catch (error) {
            console.warn('ExportManager: Auto-save failed:', error);
        }
    }

    /**
     * Utility functions
     */
    generateExportId() {
        return `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    formatTimestamp() {
        return new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Get supported export formats
     */
    getSupportedFormats() {
        return this.supportedFormats;
    }

    /**
     * Check if format is supported
     */
    isFormatSupported(format) {
        return !!this.supportedFormats[format];
    }
}

// Create global instance
window.exportManager = new ExportManager();

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ExportManager;
}